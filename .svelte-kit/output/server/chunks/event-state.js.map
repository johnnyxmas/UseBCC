{"version":3,"file":"event-state.js","sources":["../../../../node_modules/esm-env/false.js","../../../../node_modules/@sveltejs/kit/src/runtime/app/server/event.js","../../../../node_modules/@sveltejs/kit/src/runtime/shared.js","../../../../node_modules/@sveltejs/kit/src/runtime/server/event-state.js"],"sourcesContent":["export default false;\n","/** @import { RequestEvent } from '@sveltejs/kit' */\n\n/** @type {RequestEvent | null} */\nlet request_event = null;\n\n/** @type {import('node:async_hooks').AsyncLocalStorage<RequestEvent | null>} */\nlet als;\n\nimport('node:async_hooks')\n\t.then((hooks) => (als = new hooks.AsyncLocalStorage()))\n\t.catch(() => {\n\t\t// can't use AsyncLocalStorage, but can still call getRequestEvent synchronously.\n\t\t// this isn't behind `supports` because it's basically just StackBlitz (i.e.\n\t\t// in-browser usage) that doesn't support it AFAICT\n\t});\n\n/**\n * Returns the current `RequestEvent`. Can be used inside server hooks, server `load` functions, actions, and endpoints (and functions called by them).\n *\n * In environments without [`AsyncLocalStorage`](https://nodejs.org/api/async_context.html#class-asynclocalstorage), this must be called synchronously (i.e. not after an `await`).\n * @since 2.20.0\n */\nexport function getRequestEvent() {\n\tconst event = request_event ?? als?.getStore();\n\n\tif (!event) {\n\t\tlet message =\n\t\t\t'Can only read the current request event inside functions invoked during `handle`, such as server `load` functions, actions, endpoints, and other server hooks.';\n\n\t\tif (!als) {\n\t\t\tmessage +=\n\t\t\t\t' In environments without `AsyncLocalStorage`, the event must be read synchronously, not after an `await`.';\n\t\t}\n\n\t\tthrow new Error(message);\n\t}\n\n\treturn event;\n}\n\n/**\n * @template T\n * @param {RequestEvent | null} event\n * @param {() => T} fn\n */\nexport function with_event(event, fn) {\n\ttry {\n\t\trequest_event = event;\n\t\treturn als ? als.run(event, fn) : fn();\n\t} finally {\n\t\trequest_event = null;\n\t}\n}\n","/** @import { Transport } from '@sveltejs/kit' */\nimport * as devalue from 'devalue';\n\n/**\n * @param {string} route_id\n * @param {string} dep\n */\nexport function validate_depends(route_id, dep) {\n\tconst match = /^(moz-icon|view-source|jar):/.exec(dep);\n\tif (match) {\n\t\tconsole.warn(\n\t\t\t`${route_id}: Calling \\`depends('${dep}')\\` will throw an error in Firefox because \\`${match[1]}\\` is a special URI scheme`\n\t\t);\n\t}\n}\n\nexport const INVALIDATED_PARAM = 'x-sveltekit-invalidated';\n\nexport const TRAILING_SLASH_PARAM = 'x-sveltekit-trailing-slash';\n\n/**\n * Try to `devalue.stringify` the data object using the provided transport encoders.\n * @param {any} data\n * @param {Transport} transport\n */\nexport function stringify(data, transport) {\n\tconst encoders = Object.fromEntries(Object.entries(transport).map(([k, v]) => [k, v.encode]));\n\n\treturn devalue.stringify(data, encoders);\n}\n\n/**\n * Stringifies the argument (if any) for a remote function in such a way that\n * it is both a valid URL and a valid file name (necessary for prerendering).\n * @param {any} value\n * @param {Transport} transport\n */\nexport function stringify_remote_arg(value, transport) {\n\tif (value === undefined) return '';\n\n\t// If people hit file/url size limits, we can look into using something like compress_and_encode_text from svelte.dev beyond a certain size\n\tconst json_string = stringify(value, transport);\n\n\t// Convert to UTF-8 bytes, then base64 - handles all Unicode properly (btoa would fail on exotic characters)\n\tconst utf8_bytes = new TextEncoder().encode(json_string);\n\treturn btoa(String.fromCharCode(...utf8_bytes))\n\t\t.replace(/=/g, '')\n\t\t.replace(/\\+/g, '-')\n\t\t.replace(/\\//g, '_');\n}\n\n/**\n * Parses the argument (if any) for a remote function\n * @param {string} string\n * @param {Transport} transport\n */\nexport function parse_remote_arg(string, transport) {\n\tif (!string) return undefined;\n\n\tconst decoders = Object.fromEntries(Object.entries(transport).map(([k, v]) => [k, v.decode]));\n\n\t// We don't need to add back the `=`-padding because atob can handle it\n\tconst base64_restored = string.replace(/-/g, '+').replace(/_/g, '/');\n\tconst binary_string = atob(base64_restored);\n\tconst utf8_bytes = new Uint8Array([...binary_string].map((char) => char.charCodeAt(0)));\n\tconst json_string = new TextDecoder().decode(utf8_bytes);\n\n\treturn devalue.parse(json_string, decoders);\n}\n\n/**\n * @param {string} id\n * @param {string} payload\n */\nexport function create_remote_cache_key(id, payload) {\n\treturn id + '/' + payload;\n}\n","/** @import { RequestEvent } from '@sveltejs/kit' */\n/** @import { MaybePromise, PrerenderOptions, ServerHooks, SSROptions, SSRState } from 'types' */\n\nexport const EVENT_STATE = Symbol('remote');\n\n/**\n * Internal state associated with the current `RequestEvent`,\n * used for tracking things like remote function calls\n * @typedef {{\n * \tprerendering: PrerenderOptions | undefined\n *  transport: ServerHooks['transport'];\n *  handleValidationError: ServerHooks['handleValidationError'];\n *  form_instances?: Map<any, any>;\n * \tremote_data?: Record<string, MaybePromise<any>>;\n *  refreshes?: Record<string, any>;\n * }} RequestEventState\n */\n\n/**\n * @param {SSRState} state\n * @param {SSROptions} options\n * @returns {RequestEventState}\n */\nexport function create_event_state(state, options) {\n\treturn {\n\t\tprerendering: state.prerendering,\n\t\ttransport: options.hooks.transport,\n\t\thandleValidationError: options.hooks.handleValidationError\n\t};\n}\n\n/**\n * Returns internal state associated with the current `RequestEvent`\n * @param {RequestEvent} event\n * @returns {RequestEventState}\n */\nexport function get_event_state(event) {\n\t// @ts-expect-error the symbol isn't exposed on the public `RequestEvent` type\n\treturn event[EVENT_STATE];\n}\n"],"names":["BROWSER","als","request_event","getRequestEvent","event","getStore","message","Error","with_event","fn","run","validate_depends","route_id","dep","exec","import","then","hooks","AsyncLocalStorage","catch","INVALIDATED_PARAM","TRAILING_SLASH_PARAM","stringify","data","transport","encoders","Object","fromEntries","entries","map","k","v","encode","devalue","stringify_remote_arg","value","json_string","utf8_bytes","TextEncoder","btoa","String","fromCharCode","replace","parse_remote_arg","string","decoders","decode","base64_restored","binary_string","atob","Uint8Array","char","charCodeAt","TextDecoder","parse","create_remote_cache_key","id","payload","EVENT_STATE","Symbol","create_event_state","state","options","prerendering","handleValidationError","get_event_state"],"mappings":"0BAAA,MAAAA,GAAe,ECGf,IAGIC,EAHAC,EAAgB,KAmBb,SAASC,IACf,MAAMC,EAAQF,GAAiBD,GAAKI,WAEpC,IAAKD,EAAO,CACX,IAAIE,EACH,iKAOD,MALKL,IACJK,GACC,6GAGI,IAAIC,MAAMD,EACjB,CAEA,OAAOF,CACR,CAOO,SAASI,EAAWJ,EAAOK,GACjC,IAEC,OADAP,EAAgBE,EACTH,EAAMA,EAAIS,IAAIN,EAAOK,GAAMA,GACnC,CAAA,QACCP,EAAgB,IACjB,CACD,CC7CO,SAASS,EAAiBC,EAAUC,GAC5B,+BAA+BC,KAAKD,EAMnD,CDNAE,OAAO,oBACLC,KAAMC,GAAWhB,EAAM,IAAIgB,EAAMC,mBACjCC,MAAM,QCMI,MAACC,EAAoB,0BAEpBC,EAAuB,6BAO7B,SAASC,EAAUC,EAAMC,GAC/B,MAAMC,EAAWC,OAAOC,YAAYD,OAAOE,QAAQJ,GAAWK,IAAI,EAAEC,EAAGC,KAAO,CAACD,EAAGC,EAAEC,UAEpF,OAAOC,EAAQX,UAAUC,EAAME,EAChC,CAQO,SAASS,EAAqBC,EAAOX,GAC3C,QAAc,IAAVW,EAAqB,MAAO,GAGhC,MAAMC,EAAcd,EAAUa,EAAOX,GAG/Ba,GAAa,IAAIC,aAAcN,OAAOI,GAC5C,OAAOG,KAAKC,OAAOC,gBAAgBJ,IACjCK,QAAQ,KAAM,IACdA,QAAQ,MAAO,KACfA,QAAQ,MAAO,IAClB,CAOO,SAASC,EAAiBC,EAAQpB,GACxC,IAAKoB,EAAQ,OAEb,MAAMC,EAAWnB,OAAOC,YAAYD,OAAOE,QAAQJ,GAAWK,IAAI,EAAEC,EAAGC,KAAO,CAACD,EAAGC,EAAEe,UAG9EC,EAAkBH,EAAOF,QAAQ,KAAM,KAAKA,QAAQ,KAAM,KAC1DM,EAAgBC,KAAKF,GACrBV,EAAa,IAAIa,WAAW,IAAIF,GAAenB,IAAKsB,GAASA,EAAKC,WAAW,KAC7EhB,GAAc,IAAIiB,aAAcP,OAAOT,GAE7C,OAAOJ,EAAQqB,MAAMlB,EAAaS,EACnC,CAMO,SAASU,EAAwBC,EAAIC,GAC3C,OAAOD,EAAK,IAAMC,CACnB,CCzEY,MAACC,EAAcC,OAAO,UAoB3B,SAASC,EAAmBC,EAAOC,GACzC,MAAO,CACNC,aAAcF,EAAME,aACpBvC,UAAWsC,EAAQ7C,MAAMO,UACzBwC,sBAAuBF,EAAQ7C,MAAM+C,sBAEvC,CAOO,SAASC,EAAgB7D,GAE/B,OAAOA,EAAMsD,EACd","x_google_ignoreList":[0,1,2,3]}