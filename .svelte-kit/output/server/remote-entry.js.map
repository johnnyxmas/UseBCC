{"version":3,"file":"remote-entry.js","sources":["../../../node_modules/@sveltejs/kit/src/runtime/app/server/remote/shared.js","../../../node_modules/@sveltejs/kit/src/runtime/app/server/remote/command.js","../../../node_modules/@sveltejs/kit/src/runtime/app/server/remote/form.js","../../../node_modules/@sveltejs/kit/src/runtime/app/server/remote/prerender.js","../../../node_modules/@sveltejs/kit/src/runtime/app/server/remote/query.js"],"sourcesContent":["/** @import { RequestEvent } from '@sveltejs/kit' */\n/** @import { ServerHooks, MaybePromise } from 'types' */\nimport { parse } from 'devalue';\nimport { error } from '@sveltejs/kit';\nimport { getRequestEvent, with_event } from '../event.js';\nimport { create_remote_cache_key, stringify_remote_arg } from '../../../shared.js';\nimport { EVENT_STATE, get_event_state } from '../../../server/event-state.js';\n\n/**\n * @param {any} validate_or_fn\n * @param {(arg?: any) => any} [maybe_fn]\n * @returns {(arg?: any) => MaybePromise<any>}\n */\nexport function create_validator(validate_or_fn, maybe_fn) {\n\t// prevent functions without validators being called with arguments\n\tif (!maybe_fn) {\n\t\treturn (arg) => {\n\t\t\tif (arg !== undefined) {\n\t\t\t\terror(400, 'Bad Request');\n\t\t\t}\n\t\t};\n\t}\n\n\t// if 'unchecked', pass input through without validating\n\tif (validate_or_fn === 'unchecked') {\n\t\treturn (arg) => arg;\n\t}\n\n\t// use https://standardschema.dev validator if provided\n\tif ('~standard' in validate_or_fn) {\n\t\treturn async (arg) => {\n\t\t\t// Get event before async validation to ensure it's available in server environments without AsyncLocalStorage, too\n\t\t\tconst event = getRequestEvent();\n\t\t\tconst state = get_event_state(event);\n\t\t\tconst validate = validate_or_fn['~standard'].validate;\n\n\t\t\tconst result = await validate(arg);\n\n\t\t\t// if the `issues` field exists, the validation failed\n\t\t\tif (result.issues) {\n\t\t\t\terror(\n\t\t\t\t\t400,\n\t\t\t\t\tawait state.handleValidationError({\n\t\t\t\t\t\t...result,\n\t\t\t\t\t\tevent\n\t\t\t\t\t})\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn result.value;\n\t\t};\n\t}\n\n\tthrow new Error(\n\t\t'Invalid validator passed to remote function. Expected \"unchecked\" or a Standard Schema (https://standardschema.dev)'\n\t);\n}\n\n/**\n * In case of a single remote function call, just returns the result.\n *\n * In case of a full page reload, returns the response for a remote function call,\n * either from the cache or by invoking the function.\n * Also saves an uneval'ed version of the result for later HTML inlining for hydration.\n *\n * @template {MaybePromise<any>} T\n * @param {string} id\n * @param {any} arg\n * @param {RequestEvent} event\n * @param {() => Promise<T>} get_result\n * @returns {Promise<T>}\n */\nexport function get_response(id, arg, event, get_result) {\n\tconst state = get_event_state(event);\n\tconst cache_key = create_remote_cache_key(id, stringify_remote_arg(arg, state.transport));\n\n\treturn ((state.remote_data ??= {})[cache_key] ??= get_result());\n}\n\n/** @param {string} feature */\nexport function check_experimental(feature) {\n\tif (!__SVELTEKIT_EXPERIMENTAL__REMOTE_FUNCTIONS__) {\n\t\tthrow new Error(\n\t\t\t`Cannot use \\`${feature}\\` from \\`$app/server\\` without the experimental flag set to true. Please set kit.experimental.remoteFunctions to \\`true\\` in your config.`\n\t\t);\n\t}\n}\n\n/**\n * @param {any} data\n * @param {ServerHooks['transport']} transport\n */\nexport function parse_remote_response(data, transport) {\n\t/** @type {Record<string, any>} */\n\tconst revivers = {};\n\tfor (const key in transport) {\n\t\trevivers[key] = transport[key].decode;\n\t}\n\n\treturn parse(data, revivers);\n}\n\n/**\n * Like `with_event` but removes things from `event` you cannot see/call in remote functions, such as `setHeaders`.\n * @template T\n * @param {RequestEvent} event\n * @param {boolean} allow_cookies\n * @param {any} arg\n * @param {(arg: any) => any} validate\n * @param {(arg?: any) => T} fn\n */\nexport async function run_remote_function(event, allow_cookies, arg, validate, fn) {\n\t/** @type {RequestEvent} */\n\tconst cleansed = {\n\t\t...event,\n\t\t// @ts-expect-error this isn't part of the public `RequestEvent` type\n\t\t[EVENT_STATE]: event[EVENT_STATE],\n\t\tsetHeaders: () => {\n\t\t\tthrow new Error('setHeaders is not allowed in remote functions');\n\t\t},\n\t\tcookies: {\n\t\t\t...event.cookies,\n\t\t\tset: (name, value, opts) => {\n\t\t\t\tif (!allow_cookies) {\n\t\t\t\t\tthrow new Error('Cannot set cookies in `query` or `prerender` functions');\n\t\t\t\t}\n\n\t\t\t\tif (opts.path && !opts.path.startsWith('/')) {\n\t\t\t\t\tthrow new Error('Cookies set in remote functions must have an absolute path');\n\t\t\t\t}\n\n\t\t\t\treturn event.cookies.set(name, value, opts);\n\t\t\t},\n\t\t\tdelete: (name, opts) => {\n\t\t\t\tif (!allow_cookies) {\n\t\t\t\t\tthrow new Error('Cannot delete cookies in `query` or `prerender` functions');\n\t\t\t\t}\n\n\t\t\t\tif (opts.path && !opts.path.startsWith('/')) {\n\t\t\t\t\tthrow new Error('Cookies deleted in remote functions must have an absolute path');\n\t\t\t\t}\n\n\t\t\t\treturn event.cookies.delete(name, opts);\n\t\t\t}\n\t\t},\n\t\troute: { id: null },\n\t\turl: new URL(event.url.origin)\n\t};\n\n\t// In two parts, each with_event, so that runtimes without async local storage can still get the event at the start of the function\n\tconst validated = await with_event(cleansed, () => validate(arg));\n\treturn with_event(cleansed, () => fn(validated));\n}\n","/** @import { RemoteCommand } from '@sveltejs/kit' */\n/** @import { RemoteInfo, MaybePromise } from 'types' */\n/** @import { StandardSchemaV1 } from '@standard-schema/spec' */\nimport { getRequestEvent } from '../event.js';\nimport { check_experimental, create_validator, run_remote_function } from './shared.js';\nimport { get_event_state } from '../../../server/event-state.js';\n\n/**\n * Creates a remote command. When called from the browser, the function will be invoked on the server via a `fetch` call.\n *\n * See [Remote functions](https://svelte.dev/docs/kit/remote-functions#command) for full documentation.\n *\n * @template Output\n * @overload\n * @param {() => Output} fn\n * @returns {RemoteCommand<void, Output>}\n * @since 2.27\n */\n/**\n * Creates a remote command. When called from the browser, the function will be invoked on the server via a `fetch` call.\n *\n * See [Remote functions](https://svelte.dev/docs/kit/remote-functions#command) for full documentation.\n *\n * @template Input\n * @template Output\n * @overload\n * @param {'unchecked'} validate\n * @param {(arg: Input) => Output} fn\n * @returns {RemoteCommand<Input, Output>}\n * @since 2.27\n */\n/**\n * Creates a remote command. When called from the browser, the function will be invoked on the server via a `fetch` call.\n *\n * See [Remote functions](https://svelte.dev/docs/kit/remote-functions#command) for full documentation.\n *\n * @template {StandardSchemaV1} Schema\n * @template Output\n * @overload\n * @param {Schema} validate\n * @param {(arg: StandardSchemaV1.InferOutput<Schema>) => Output} fn\n * @returns {RemoteCommand<StandardSchemaV1.InferInput<Schema>, Output>}\n * @since 2.27\n */\n/**\n * @template Input\n * @template Output\n * @param {any} validate_or_fn\n * @param {(arg?: Input) => Output} [maybe_fn]\n * @returns {RemoteCommand<Input, Output>}\n * @since 2.27\n */\n/*@__NO_SIDE_EFFECTS__*/\nexport function command(validate_or_fn, maybe_fn) {\n\tcheck_experimental('command');\n\n\t/** @type {(arg?: Input) => Output} */\n\tconst fn = maybe_fn ?? validate_or_fn;\n\n\t/** @type {(arg?: any) => MaybePromise<Input>} */\n\tconst validate = create_validator(validate_or_fn, maybe_fn);\n\n\t/** @type {RemoteInfo} */\n\tconst __ = { type: 'command', id: '', name: '' };\n\n\t/** @type {RemoteCommand<Input, Output> & { __: RemoteInfo }} */\n\tconst wrapper = (arg) => {\n\t\tconst event = getRequestEvent();\n\n\t\tif (!event.isRemoteRequest) {\n\t\t\tthrow new Error(\n\t\t\t\t`Cannot call a command (\\`${__.name}(${maybe_fn ? '...' : ''})\\`) during server-side rendering`\n\t\t\t);\n\t\t}\n\n\t\tget_event_state(event).refreshes ??= {};\n\n\t\tconst promise = Promise.resolve(run_remote_function(event, true, arg, validate, fn));\n\n\t\t// @ts-expect-error\n\t\tpromise.updates = () => {\n\t\t\tthrow new Error(`Cannot call '${__.name}(...).updates(...)' on the server`);\n\t\t};\n\n\t\treturn /** @type {ReturnType<RemoteCommand<Input, Output>>} */ (promise);\n\t};\n\n\tObject.defineProperty(wrapper, '__', { value: __ });\n\n\treturn wrapper;\n}\n","/** @import { RemoteForm } from '@sveltejs/kit' */\n/** @import { RemoteInfo, MaybePromise } from 'types' */\nimport { getRequestEvent } from '../event.js';\nimport { check_experimental, run_remote_function } from './shared.js';\nimport { get_event_state } from '../../../server/event-state.js';\n\n/**\n * Creates a form object that can be spread onto a `<form>` element.\n *\n * See [Remote functions](https://svelte.dev/docs/kit/remote-functions#form) for full documentation.\n *\n * @template T\n * @param {(data: FormData) => MaybePromise<T>} fn\n * @returns {RemoteForm<T>}\n * @since 2.27\n */\n/*@__NO_SIDE_EFFECTS__*/\n// @ts-ignore we don't want to prefix `fn` with an underscore, as that will be user-visible\nexport function form(fn) {\n\tcheck_experimental('form');\n\n\t/**\n\t * @param {string | number | boolean} [key]\n\t */\n\tfunction create_instance(key) {\n\t\t/** @type {RemoteForm<T>} */\n\t\tconst instance = {};\n\n\t\tinstance.method = 'POST';\n\t\tinstance.onsubmit = () => {};\n\n\t\tObject.defineProperty(instance, 'enhance', {\n\t\t\tvalue: () => {\n\t\t\t\treturn { action: instance.action, method: instance.method, onsubmit: instance.onsubmit };\n\t\t\t}\n\t\t});\n\n\t\tconst button_props = {\n\t\t\ttype: 'submit',\n\t\t\tonclick: () => {}\n\t\t};\n\n\t\tObject.defineProperty(button_props, 'enhance', {\n\t\t\tvalue: () => {\n\t\t\t\treturn { type: 'submit', formaction: instance.buttonProps.formaction, onclick: () => {} };\n\t\t\t}\n\t\t});\n\n\t\tObject.defineProperty(instance, 'buttonProps', {\n\t\t\tvalue: button_props\n\t\t});\n\n\t\t/** @type {RemoteInfo} */\n\t\tconst __ = {\n\t\t\ttype: 'form',\n\t\t\tname: '',\n\t\t\tid: '',\n\t\t\t/** @param {FormData} form_data */\n\t\t\tfn: async (form_data) => {\n\t\t\t\tconst event = getRequestEvent();\n\t\t\t\tconst state = get_event_state(event);\n\n\t\t\t\tstate.refreshes ??= {};\n\n\t\t\t\tconst result = await run_remote_function(event, true, form_data, (d) => d, fn);\n\n\t\t\t\t// We don't need to care about args or deduplicating calls, because uneval results are only relevant in full page reloads\n\t\t\t\t// where only one form submission is active at the same time\n\t\t\t\tif (!event.isRemoteRequest) {\n\t\t\t\t\t(state.remote_data ??= {})[__.id] = result;\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t}\n\t\t};\n\n\t\tObject.defineProperty(instance, '__', { value: __ });\n\n\t\tObject.defineProperty(instance, 'action', {\n\t\t\tget: () => `?/remote=${__.id}`,\n\t\t\tenumerable: true\n\t\t});\n\n\t\tObject.defineProperty(button_props, 'formaction', {\n\t\t\tget: () => `?/remote=${__.id}`,\n\t\t\tenumerable: true\n\t\t});\n\n\t\tObject.defineProperty(instance, 'result', {\n\t\t\tget() {\n\t\t\t\ttry {\n\t\t\t\t\tconst { remote_data } = get_event_state(getRequestEvent());\n\t\t\t\t\treturn remote_data?.[__.id];\n\t\t\t\t} catch {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tif (key == undefined) {\n\t\t\tObject.defineProperty(instance, 'for', {\n\t\t\t\t/** @type {RemoteForm<any>['for']} */\n\t\t\t\tvalue: (key) => {\n\t\t\t\t\tconst state = get_event_state(getRequestEvent());\n\t\t\t\t\tlet instance = (state.form_instances ??= new Map()).get(key);\n\n\t\t\t\t\tif (!instance) {\n\t\t\t\t\t\tinstance = create_instance(key);\n\t\t\t\t\t\tinstance.__.id = `${__.id}/${encodeURIComponent(JSON.stringify(key))}`;\n\t\t\t\t\t\tinstance.__.name = __.name;\n\n\t\t\t\t\t\tstate.form_instances.set(key, instance);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn instance;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\treturn instance;\n\t}\n\n\treturn create_instance();\n}\n","/** @import { RemoteResource, RemotePrerenderFunction } from '@sveltejs/kit' */\n/** @import { RemotePrerenderInputsGenerator, RemoteInfo, MaybePromise } from 'types' */\n/** @import { StandardSchemaV1 } from '@standard-schema/spec' */\nimport { error, json } from '@sveltejs/kit';\nimport { DEV } from 'esm-env';\nimport { getRequestEvent } from '../event.js';\nimport { create_remote_cache_key, stringify, stringify_remote_arg } from '../../../shared.js';\nimport { app_dir, base } from '__sveltekit/paths';\nimport {\n\tcheck_experimental,\n\tcreate_validator,\n\tget_response,\n\tparse_remote_response,\n\trun_remote_function\n} from './shared.js';\nimport { get_event_state } from '../../../server/event-state.js';\n\n/**\n * Creates a remote prerender function. When called from the browser, the function will be invoked on the server via a `fetch` call.\n *\n * See [Remote functions](https://svelte.dev/docs/kit/remote-functions#prerender) for full documentation.\n *\n * @template Output\n * @overload\n * @param {() => MaybePromise<Output>} fn\n * @param {{ inputs?: RemotePrerenderInputsGenerator<void>, dynamic?: boolean }} [options]\n * @returns {RemotePrerenderFunction<void, Output>}\n * @since 2.27\n */\n/**\n * Creates a remote prerender function. When called from the browser, the function will be invoked on the server via a `fetch` call.\n *\n * See [Remote functions](https://svelte.dev/docs/kit/remote-functions#prerender) for full documentation.\n *\n * @template Input\n * @template Output\n * @overload\n * @param {'unchecked'} validate\n * @param {(arg: Input) => MaybePromise<Output>} fn\n * @param {{ inputs?: RemotePrerenderInputsGenerator<Input>, dynamic?: boolean }} [options]\n * @returns {RemotePrerenderFunction<Input, Output>}\n * @since 2.27\n */\n/**\n * Creates a remote prerender function. When called from the browser, the function will be invoked on the server via a `fetch` call.\n *\n * See [Remote functions](https://svelte.dev/docs/kit/remote-functions#prerender) for full documentation.\n *\n * @template {StandardSchemaV1} Schema\n * @template Output\n * @overload\n * @param {Schema} schema\n * @param {(arg: StandardSchemaV1.InferOutput<Schema>) => MaybePromise<Output>} fn\n * @param {{ inputs?: RemotePrerenderInputsGenerator<StandardSchemaV1.InferInput<Schema>>, dynamic?: boolean }} [options]\n * @returns {RemotePrerenderFunction<StandardSchemaV1.InferInput<Schema>, Output>}\n * @since 2.27\n */\n/**\n * @template Input\n * @template Output\n * @param {any} validate_or_fn\n * @param {any} [fn_or_options]\n * @param {{ inputs?: RemotePrerenderInputsGenerator<Input>, dynamic?: boolean }} [maybe_options]\n * @returns {RemotePrerenderFunction<Input, Output>}\n * @since 2.27\n */\n/*@__NO_SIDE_EFFECTS__*/\nexport function prerender(validate_or_fn, fn_or_options, maybe_options) {\n\tcheck_experimental('prerender');\n\n\tconst maybe_fn = typeof fn_or_options === 'function' ? fn_or_options : undefined;\n\n\t/** @type {typeof maybe_options} */\n\tconst options = maybe_options ?? (maybe_fn ? undefined : fn_or_options);\n\n\t/** @type {(arg?: Input) => MaybePromise<Output>} */\n\tconst fn = maybe_fn ?? validate_or_fn;\n\n\t/** @type {(arg?: any) => MaybePromise<Input>} */\n\tconst validate = create_validator(validate_or_fn, maybe_fn);\n\n\t/** @type {RemoteInfo} */\n\tconst __ = {\n\t\ttype: 'prerender',\n\t\tid: '',\n\t\tname: '',\n\t\thas_arg: !!maybe_fn,\n\t\tinputs: options?.inputs,\n\t\tdynamic: options?.dynamic\n\t};\n\n\t/** @type {RemotePrerenderFunction<Input, Output> & { __: RemoteInfo }} */\n\tconst wrapper = (arg) => {\n\t\t/** @type {Promise<Output> & Partial<RemoteResource<Output>>} */\n\t\tconst promise = (async () => {\n\t\t\tconst event = getRequestEvent();\n\t\t\tconst state = get_event_state(event);\n\t\t\tconst payload = stringify_remote_arg(arg, state.transport);\n\t\t\tconst id = __.id;\n\t\t\tconst url = `${base}/${app_dir}/remote/${id}${payload ? `/${payload}` : ''}`;\n\n\t\t\tif (!state.prerendering && !DEV && !event.isRemoteRequest) {\n\t\t\t\ttry {\n\t\t\t\t\treturn await get_response(id, arg, event, async () => {\n\t\t\t\t\t\t// TODO adapters can provide prerendered data more efficiently than\n\t\t\t\t\t\t// fetching from the public internet\n\t\t\t\t\t\tconst response = await fetch(new URL(url, event.url.origin).href);\n\n\t\t\t\t\t\tif (!response.ok) {\n\t\t\t\t\t\t\tthrow new Error('Prerendered response not found');\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst prerendered = await response.json();\n\n\t\t\t\t\t\tif (prerendered.type === 'error') {\n\t\t\t\t\t\t\terror(prerendered.status, prerendered.error);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// TODO can we redirect here?\n\n\t\t\t\t\t\t(state.remote_data ??= {})[create_remote_cache_key(id, payload)] = prerendered.result;\n\t\t\t\t\t\treturn parse_remote_response(prerendered.result, state.transport);\n\t\t\t\t\t});\n\t\t\t\t} catch {\n\t\t\t\t\t// not available prerendered, fallback to normal function\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (state.prerendering?.remote_responses.has(url)) {\n\t\t\t\treturn /** @type {Promise<any>} */ (state.prerendering.remote_responses.get(url));\n\t\t\t}\n\n\t\t\tconst promise = get_response(id, arg, event, () =>\n\t\t\t\trun_remote_function(event, false, arg, validate, fn)\n\t\t\t);\n\n\t\t\tif (state.prerendering) {\n\t\t\t\tstate.prerendering.remote_responses.set(url, promise);\n\t\t\t}\n\n\t\t\tconst result = await promise;\n\n\t\t\tif (state.prerendering) {\n\t\t\t\tconst body = { type: 'result', result: stringify(result, state.transport) };\n\t\t\t\tstate.prerendering.dependencies.set(url, {\n\t\t\t\t\tbody: JSON.stringify(body),\n\t\t\t\t\tresponse: json(body)\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// TODO this is missing error/loading/current/status\n\t\t\treturn result;\n\t\t})();\n\n\t\tpromise.catch(() => {});\n\n\t\treturn /** @type {RemoteResource<Output>} */ (promise);\n\t};\n\n\tObject.defineProperty(wrapper, '__', { value: __ });\n\n\treturn wrapper;\n}\n","/** @import { RemoteQuery, RemoteQueryFunction } from '@sveltejs/kit' */\n/** @import { RemoteInfo, MaybePromise } from 'types' */\n/** @import { StandardSchemaV1 } from '@standard-schema/spec' */\nimport { getRequestEvent } from '../event.js';\nimport { create_remote_cache_key, stringify_remote_arg } from '../../../shared.js';\nimport { prerendering } from '__sveltekit/environment';\nimport {\n\tcheck_experimental,\n\tcreate_validator,\n\tget_response,\n\trun_remote_function\n} from './shared.js';\nimport { get_event_state } from '../../../server/event-state.js';\n\n/**\n * Creates a remote query. When called from the browser, the function will be invoked on the server via a `fetch` call.\n *\n * See [Remote functions](https://svelte.dev/docs/kit/remote-functions#query) for full documentation.\n *\n * @template Output\n * @overload\n * @param {() => MaybePromise<Output>} fn\n * @returns {RemoteQueryFunction<void, Output>}\n * @since 2.27\n */\n/**\n * Creates a remote query. When called from the browser, the function will be invoked on the server via a `fetch` call.\n *\n * See [Remote functions](https://svelte.dev/docs/kit/remote-functions#query) for full documentation.\n *\n * @template Input\n * @template Output\n * @overload\n * @param {'unchecked'} validate\n * @param {(arg: Input) => MaybePromise<Output>} fn\n * @returns {RemoteQueryFunction<Input, Output>}\n * @since 2.27\n */\n/**\n * Creates a remote query. When called from the browser, the function will be invoked on the server via a `fetch` call.\n *\n * See [Remote functions](https://svelte.dev/docs/kit/remote-functions#query) for full documentation.\n *\n * @template {StandardSchemaV1} Schema\n * @template Output\n * @overload\n * @param {Schema} schema\n * @param {(arg: StandardSchemaV1.InferOutput<Schema>) => MaybePromise<Output>} fn\n * @returns {RemoteQueryFunction<StandardSchemaV1.InferInput<Schema>, Output>}\n * @since 2.27\n */\n/**\n * @template Input\n * @template Output\n * @param {any} validate_or_fn\n * @param {(args?: Input) => MaybePromise<Output>} [maybe_fn]\n * @returns {RemoteQueryFunction<Input, Output>}\n * @since 2.27\n */\n/*@__NO_SIDE_EFFECTS__*/\nexport function query(validate_or_fn, maybe_fn) {\n\tcheck_experimental('query');\n\n\t/** @type {(arg?: Input) => Output} */\n\tconst fn = maybe_fn ?? validate_or_fn;\n\n\t/** @type {(arg?: any) => MaybePromise<Input>} */\n\tconst validate = create_validator(validate_or_fn, maybe_fn);\n\n\t/** @type {RemoteInfo} */\n\tconst __ = { type: 'query', id: '', name: '' };\n\n\t/** @type {RemoteQueryFunction<Input, Output> & { __: RemoteInfo }} */\n\tconst wrapper = (arg) => {\n\t\tif (prerendering) {\n\t\t\tthrow new Error(\n\t\t\t\t`Cannot call query '${__.name}' while prerendering, as prerendered pages need static data. Use 'prerender' from $app/server instead`\n\t\t\t);\n\t\t}\n\n\t\tconst event = getRequestEvent();\n\n\t\t/** @type {Promise<any> & Partial<RemoteQuery<any>>} */\n\t\tconst promise = get_response(__.id, arg, event, () =>\n\t\t\trun_remote_function(event, false, arg, validate, fn)\n\t\t);\n\n\t\tpromise.catch(() => {});\n\n\t\tpromise.refresh = async () => {\n\t\t\tconst event = getRequestEvent();\n\t\t\tconst state = get_event_state(event);\n\t\t\tconst refreshes = state?.refreshes;\n\n\t\t\tif (!refreshes) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Cannot call refresh on query '${__.name}' because it is not executed in the context of a command/form remote function`\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tconst cache_key = create_remote_cache_key(__.id, stringify_remote_arg(arg, state.transport));\n\t\t\trefreshes[cache_key] = await /** @type {Promise<any>} */ (promise);\n\t\t};\n\n\t\tpromise.withOverride = () => {\n\t\t\tthrow new Error(`Cannot call '${__.name}.withOverride()' on the server`);\n\t\t};\n\n\t\treturn /** @type {RemoteQuery<Output>} */ (promise);\n\t};\n\n\tObject.defineProperty(wrapper, '__', { value: __ });\n\n\treturn wrapper;\n}\n"],"names":["create_validator","validate_or_fn","maybe_fn","arg","error","async","event","getRequestEvent","state","get_event_state","validate","result","issues","handleValidationError","value","Error","get_response","id","get_result","cache_key","create_remote_cache_key","stringify_remote_arg","transport","remote_data","check_experimental","feature","run_remote_function","allow_cookies","fn","cleansed","EVENT_STATE","setHeaders","cookies","set","name","opts","path","startsWith","delete","route","url","URL","origin","validated","with_event","command","__","type","wrapper","isRemoteRequest","refreshes","promise","Promise","resolve","updates","Object","defineProperty","form","create_instance","key","instance","action","method","onsubmit","button_props","onclick","formaction","buttonProps","form_data","d","get","enumerable","form_instances","Map","encodeURIComponent","JSON","stringify","prerender","fn_or_options","maybe_options","options","has_arg","inputs","dynamic","payload","base","app_dir","prerendering","DEV","response","fetch","href","ok","prerendered","json","status","data","revivers","decode","parse","parse_remote_response","remote_responses","has","body","dependencies","catch","query","refresh","withOverride"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4]}